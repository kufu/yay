private, symbol
=== 
# private

> 参考 : かんたんRuby 9-05 P257

Rubyにおいて覚えるべきメソッドのアクセスコントロールは、publicかprivateかです。言語仕様としてprotectedは存在しますが、明らかに期待と異なる動作をするため覚える必要はありません。
歴史的経緯でいえば、RubyのprotectedはSmalltalkではなくC++やJavaに影響されて作られましたが、それを鑑みても期待とは異なるので、使わないほうが無難です。
その一方で、privateはとても良く使います。また、ルールも非常に簡単なので、必ず覚えましょう。

以前覚えたとおり、Rubyでは全てがオブジェクトであり、メソッドはオブジェクトに所属しています。そのため、メソッド呼び出しには必ずレシーバーが存在し、省略した場合はselfが用いられます。
privateメソッドは、『レシーバーを省略した状態でなければ呼び出せないメソッド』です。Rubyのドキュメントでは『private に設定されたメソッドは関数形式でしか呼び出せません』と表現されています。
これはとてもシンプルなルールなので、すでに学んだ知識と合わせて復習しましょう。

1. すべてのメソッドにはレシーバーが存在する
2. レシーバーを省略するとselfがレシーバーになる
3. privateはレシーバーを省略しないと呼び出せない

つまり、privateのメソッドは、暗黙のselfをレシーバーにした場合のみ呼び出せるメソッドです。

```ruby
class Somethiong
  def hoge
    foo
  end

  private

  def foo
    "piyo"
  end
end

Something.new.foo # => 呼び出せずエラーになる、なぜなら `foo` メソッドは、明示的にレシーバー `Something.new` をとっている
Something.new.hoge # => "piyo" が返る。Something#hogeメソッドの中では、fooのレシーバーを指定していない（つまり暗黙のselfがレシーバー）ため、呼び出せる。
```

あまり本筋とは関係ないですが、Ruby2.7から一つの面白い挙動が許されるようになったので、紹介します。

```ruby
class Something

  def foo
    self.hoge
  end

  private

  def hoge
    "h"
  end
end

Something.new.foo # => "h"
```

このコードは、Ruby2.7以降のバージョンとRuby2.6以下のバージョンで実行すると、それぞれ違う結果になります。
`hoge` はプライベートメソッドなので、明示的なレシーバーを指定することはできません。しかし、 `foo` メソッドの中では、 `hoge` に `self` というレシーバーを明示して呼び出しています。
このコードは、2.6以下ではエラーとなり、2.7以上ではエラーにならず `hoge` を呼び出すことができます。
厳密にルールに則った考え方をすれば、たとえ `self` であったとしても、明示的なレシーバーを設定した呼び出しは許可されません。
この変更は、次のようなケースで2.6までで許可されていたprivateの抜け穴と挙動を揃えるために変更されたものです。

```ruby
class Something
  def hoge
    self.foo = "hoge"
  end

  private

  def foo=(v)
    @foo = v
  end
end

Something.new.hoge # => "hoge"
```

一見すると、 `foo=` メソッドはアクセサメソッドですがprivateなので `hoge` メソッドは失敗しそうですが、2.6以下のRubyでもこのコードはエラーにならず動きます。
この様に、僅かな例外があったprivateメソッドの挙動に揃えるために、2.7からは明示的な `self` をレシーバーにした場合でもprivageメソッドの呼び出しが許可されるようになりました。

## コラム：アクセサメソッド、再定義可能なメソッド

さらっと `def foo=(v)` をアクセサメソッドとして話してしまいましたが、これはRubyのメソッド定義において演算子式の定義と呼ばれるメソッドです。
[クラス／メソッドの定義](https://docs.ruby-lang.org/ja/master/doc/spec=2fdef.html)
`obj.foo = "piyo"` のような式は、実行時に `obj.foo=("foo")` のような形で解釈されます。つまり、objのfooに"piyo"を代入する、というふうに読めるこの式は、実はobjの `foo=` メソッドを呼んでいるに過ぎません。
`foo=` メソッドは、なにか特別なことをしない限りは、ユーザーが自由に定義できるメソッドです。一つ前の例では、引数を一つ取ってその引数をオブジェクト変数に代入する挙動をしていますが、実際には何を書こうがユーザーの自由です。
このように、Rubyにおいてはアクセサもすべてメソッドです。また同様に、演算子もすべてメソッドです。特定の演算子に関しては、ユーザーが再定義することも可能です。
詳しくは、マニュアルの[クラス／メソッドの定義#演算子式の定義](https://docs.ruby-lang.org/ja/master/doc/spec=2fdef.html#operator)と、[演算子式](https://docs.ruby-lang.org/ja/master/doc/spec=2foperator.html)の「再定義できる演算子」を参照してください。

# String と Symbol

> 参考 : かんたんRuby 5-06 P157

Rubyを学ぶときにぶち当たる謎の概念として、ブロックと双璧をなすのがシンボルだと思います。
シンボルは、端的に言うとStaticな文字列です。処理系の中で一つのIDが与えられ、その値は不変です。

```ruby
"test".object_id # => 70262880234840
"test".object_id # => 70262880234700

:test.object_id # => 375708
:test.object_id # => 375708
```

`Object#object_id` は、オブジェクトごとの一意の値を表します。1行目の文字列`"test"` と2行目の文字列 `"test"` は、全く同じ内容のオブジェクトですが、object_idを見ると別のオブジェクトであることがわかります。
これは、Stringオブジェクトを生成するリテラルによって、都度Stringオブジェクトが生成されているためで、1行目のオブジェクトと2行目のオブジェクトの間になんら関連性が無いことを表しています。
一方で、4行目の `:test` と5行目の `:test` は、全く同じオブジェクトであることがわかります。 `:` はシンボルを作成するリテラルですが、シンボルは実行中のどの場面で作成されても、同じ文字列であれば必ず同一のオブジェクトを返すことが保証されています。
処理系での話をすると、シンボルはユーザーの記述するコード上では文字列のように扱われますが、処理系の中では整数として扱われてます。
この特性から、シンボルは処理系内部でのメソッド名の管理や、変数名、定数名、クラス名などあらゆる名前を管理するオブジェクトとして利用されています。メソッドを定義したときにシンボルが返るのは、これが理由です。
また、もっとユーザーよりのユースケースでは、ハッシュのキーとして扱われることが多いです。

```ruby
hash = {}
hash[:key1] = "value1"
hash[:key2] = "value2"

p hash #=> {:key1=>"value1", :key2=>"value2"}
```

さらに、シンボルと文字列は相互変換が可能です。
SymbolオブジェクトをStringオブジェクトに変えるには `to_s` メソッド、StringオブジェクトをSymbolに変えるには `to_sym` メソッドを使います。

```ruby
:hoge.object_id # => 1056668
:hoge.to_s.object_id # => 70144701615320
:hoge.to_s.object_id # => 70144701615260

"hoge".to_sym.object_id # => 1056668
"hoge".to_sym.object_id # => 1056668
```

この変換の中でも、文字列からシンボルに変換されると必ず一意のIDを示し、シンボルを文字列に変えると都度違うIDを持つことがわかります。
